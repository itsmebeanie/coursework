/// ------------ ///
Introduction & Logistics
/// ------------ ///
Approaching Problems

/// ------------ ///
Data Structures + Union Find

/// ------------ ///
Bit Masks + Segment Trees


/// ------------ ///
Fenwick Trees

/// ------------ ///
Complete Search + Greedy

/// ------------ ///
Divide + Conqur

/// ------------ ///
Dynamic Programming:


All integer values within reasonable range
- N distinct integers: how can we compose ordered list with sum S by
choosing the values from the sum-letter

Straightforward: f(s) number of ways we can compose the sum S
number of ways of sum of the smaller sums + ways of sum of current
f(s-vi)
Order
in increasing S

DAG (top)
first level v1 to vn
Looking at Nodes:
how can we compose S1
last two choices of decisions, pick s11
Two paths will be using the same node
from Sn, what decisions have we made to gt here


Not much different
recursive function
if we already computed the dp entry then we return it
iterate through all possible vis and subtract from current sum
boundary conditions: negative sums

(bottom up)
Making decisions table from sum = 0 to get s21 etc.
1 way to to sum 0
smaller sums that we already computed to get sum

Two toposort algorithms
- Assuming graph is a DAG
- Topological order of any dag (2 Algorithms - dfs and queue)
Kahn's algorithm:
Indegree
Push 0 indegree into our queue
Immediate neighbors
decrement indegree of neighbors
until last nodes with indegree with 0 (top of topological order)
queue
pop
remove edges incident to c
decrement indegree of last node - E is on queue
Topological order: Order that pop out elements out of the queue
DFS algorithm:
Visit some of the nodes that already have no further children in the dfs tree
Node is at the head of the toplogical order
DFS complete to child recurse back (not completed if there is an outgoing edge, keep traversing outgoing edges)
Topsort: is like bottom-up DP using kahn's algorithm
(Boundary cases we know)
Naturally follow the order of the topological sort
DFS: Top-down
Recursive routings: Don't compute the relations again

As long as a DAG exist you can use a top-sort and compute order.

Cutting Sticks
Stick of integer length L cut into multiple segments
List of length, value pairs for every lengthTask is to maximize total value

DP Sates
cut(L) maximum for a stick of length L
Transition
cut(L) max (value(i) + cut(L-i))
Order:
Larger L depends on smaller L's

DAG

Top down
Action of cutting top down is more intuitive
if (dp[L]) != -1 return dp[L]
for all the L
ans = maximum value of all the L choices

Bottom up
Complete DAG - maximum possible of edges
every node has all the possible edges going to dependencies

DAG lets you determine if a problem is solvable by dp

Grid walking:
Reach bottom right cell from top left cell
You can only move right or down
Count the number of ways you can move this cell
* 3 ways for example

Model the problem into DAG(straightforward)
ways(i,k) ways to reach cell(i,j) from starting cell
Transition
ways(i,j) = ways(i-1,j) + ways(i,j-1)

Implement dp:
Implicit dp
iterating i and j
dp NN
j 1 to N i j to N
iterate every cell first by row and them by columns
each o dp value depends on i-1,j i,j-1 to dp i, j
return dp(N)(N)


Top down: Out of range
(pari of i j is value
then use recursive routing
dp i, j will depend on recursive i,j
edge cases
if its out  then its 0


DAG - extend grid walking problems by allowing you to walking 4 directions
If it's not a DAG you cannot do DP

What should we do if the question is not a DAG:
Mark previous states

DAG creation
i, j, k
way to go to i j with k steps
Build DAG in this way -> every node has outgoing edges

How to implement
Add one more dimension to DP code
- Top down, new argument of your recursive function
- Bottom up, multidimensional array

Subtle differences between bottom up and top down
stack size

DP procedural:
Formulate the DAG
Guidelines are feasable
Memory I consume must be smaller than the memory limit

F(N) - O(N) memory

Grid walking
O(M*N) place * K layers if you're not using memory saving trick

Affordable time:
- DP DAG - C states then your time complexity is Omega(C)
Have to take C steps to compute everything

Types of DP Problems:
Fibonacci Sequence
Counting ProblemCutting Sticks
Grid Walking
Grid Walking 2 with 4 cardinal directions


Finding DP states:
important variables used as a dimension of the DP state
Not directly demand


Minimum balance:
N possible integers as a multiset (a1 .. aN) not necessarily distinct values
two multisets so that the sum of the multisets hav the smallest possible absolute difference
e.g.
1234
1, 4 -  2 , 3 ; 0 difference
State possible (i,S) whether we can find a multiset of integers with sum S among the first integers
Note that S is not directly given in the problem
Finding S that possible(n,s) is true and is close to midle point of S total
Whatever previously possible -> Next posible

for each level if the previous level is possible then this level is already possible.
---
Lucky Strings:
It's lucky if it contains lucky character t
How many lucky strings exist with length L so it contains lucky characters
a b c
b
length 3

Lucky Strings - DP Formulation

count(i,exist)
exist-  i have written lucky character
Number ways to include a string of length i i
Highly dependent on dp procedure rather than problem itself

if first letter isn't then its still false
all letters y must be distinct

Lucky Strings 2
Replace exists by integer value m, perviously written m letters will match the prefix of y
how many letters have matched through the way doing dp

Have to handle integer overflows
Make sure that don't overflow integers when you're doing modulo
- make sure to do this for E


Number of blocks
r red blocks
g green blocks
h red bloccks or h green blovks
r-h,  r

g-h, g
